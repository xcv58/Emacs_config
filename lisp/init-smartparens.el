(require-package 'smartparens)
(require 'smartparens-config)
(require 'smartparens-latex)

(smartparens-global-mode t)
(sp-pair "(" ")" :wrap "C-(")
(sp-pair "$" "$" :wrap "C-4")
(sp-pair "(" ")" :wrap "C-)")
(sp-pair "{" "}" :wrap "C-{")
(sp-pair "{" "}" :wrap "C-}")
(sp-pair "\"" "\"" :wrap "C-\"")

(define-key sp-keymap (kbd "C-c ,") 'sp-up-sexp)
;; (define-key sp-keymap (kbd "M-e") 'sp-up-sexp)
(define-key sp-keymap (kbd "M-b") 'sp-backward-sexp)
(define-key sp-keymap (kbd "M-f") 'sp-forward-sexp)
(define-key sp-keymap (kbd "C-c k") 'sp-kill-sexp)
(define-key sp-keymap (kbd "C-c u") 'sp-unwrap-sexp)

(defun sp-next-sexp-without-cross-line (&optional point)
  (interactive)
  (if point (goto-char point))
  (let ((position (point)) (line (line-number-at-pos)))
    (sp-next-sexp)
    (if (/= line (line-number-at-pos))
        (goto-char position))
    (point)))

(defun sp-up-sexp-without-cross-line (&optional point)
  (interactive)
  (if point (goto-char point))
  (let ((position (point)) (line (line-number-at-pos)))
    (sp-up-sexp)
    (if (/= line (line-number-at-pos))
        (goto-char position))
    (point)))

(defun end-of-this()
  (interactive)
  (unless (= (point) (line-end-position))
    (let* ((point (point))
           (up-point (sp-up-sexp-without-cross-line point))
           (next-point (sp-next-sexp-without-cross-line point)))
      (goto-char (if (>= point (min up-point next-point))
                     (if (>= point (max up-point next-point))
                         (line-end-position)
                       (max up-point next-point))
                   (min up-point next-point))))))

(define-key evil-insert-state-map "\C-e" 'end-of-this)
(define-key evil-insert-state-map "\M-e" 'end-of-line)


(provide 'init-smartparens)
